<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapLibre GL JS - Load Default Features from API</title>
    <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
    <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.css"
        rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            width: 100%;
            height: 300px;
        }

        #style-form {
            /* position: absolute;
            top: 0;
            left: 0; */
            background: white;
            padding: 10px;
            z-index: 1;
        }

        select {
            width: 100%;
            margin-top: 5px;
        }
    </style>
</head>

<body>

    <div id="map"></div>
    <form id="styleForm">
        <h3>Style Settings</h3>
        <div>
            <label>Point Color: <input type="color" id="point-color" value="#FF0000"></label>
            <label>Point Size: <input type="number" id="point-radius" min="1" max="20" value="8"></label>
        </div>
        <div>
            <label>Line Color: <input type="color" id="line-color" value="#00FF00"></label>
            <label>Line Width: <input type="number" id="line-width" min="1" max="10" value="2"></label>
        </div>
        <div>
            <label>Polygon Color: <input type="color" id="polygon-color" value="#0000FF"></label>
            <label>Opacity: <input type="number" id="polygon-opacity" min="0" max="1" step="0.1" value="0.5"></label>
        </div>
        <div>
            <label>Marker Icon:
                <select id="marker-icon">
                    <option value="map-marker">Map Marker</option>
                    <option value="star">Star</option>
                    <option value="home">Home</option>
                    <option value="car">Car</option>
                    <option value="tree">Tree</option>
                    <option value="flag">Flag</option>
                    <option value="heart">Heart</option>
                    <option value="user">User</option>
                    <option value="lock">Lock</option>
                    <option value="phone">Phone</option>
                    <option value="bell">Bell</option>
                    <option value="camera">Camera</option>
                    <option value="coffee">Coffee</option>
                    <option value="envelope">Envelope</option>
                    <option value="gift">Gift</option>
                    <option value="plane">Plane</option>
                    <option value="rocket">Rocket</option>
                    <option value="shopping-cart">Shopping Cart</option>
                    <option value="tag">Tag</option>
                    <option value="thumbs-up">Thumbs Up</option>
                    <option value="trophy">Trophy</option>
                    <option value="truck">Truck</option>
                    <option value="umbrella">Umbrella</option>
                    <option value="wrench">Wrench</option>
                    <option value="anchor">Anchor</option>
                    <option value="bicycle">Bicycle</option>
                    <option value="bolt">Bolt</option>
                    <option value="cloud">Cloud</option>
                    <option value="globe">Globe</option>
                    <option value="leaf">Leaf</option>
                </select>
            </label>
        </div>
        <button type="submit">Apply Styles</button>
    </form>

    <form id="style-form">
        <h3>Style Settings</h3>
        <div>
            <label for="baseMapSelector" class="form-label">เลือกแผนที่ฐาน</label>
            <select class="form-select" id="baseMapSelector">
                <option value="maptiler">Maptiler 3D</option>
                <option value="osm" selected>OpenStreetMap</option>
                <option value="grod">Google Road</option>
                <option value="gsat">Google Satellite</option>
                <option value="ghyb">Google Hybrid</option>
            </select>
        </div>
    </form>

    <form id="searchLatLng">
        <div class="mb-3">
            <label for="latitude" class="form-label">ละติจูด</label>
            <input type="text" class="form-control" id="latitude" placeholder="Enter latitude" required>
        </div>
        <div class="mb-3">
            <label for="longitude" class="form-label">ลองจิจูด</label>
            <input type="text" class="form-control" id="longitude" placeholder="Enter longitude" required>
        </div>
        <div class="d-flex gap-2">
            <button type="submit" class="btn btn-primary">ค้นหา</button>
            <button type="button" class="btn btn-primary" id="clear-marker">ลบ</button>
        </div>
    </form>

    <div id="formContainer"></div><input type="hidden" id="refid">
    <script>
        document.addEventListener('DOMContentLoaded', async function () {
            try {
                const API_KEYS = {
                    MAPTILER: 'QcH5sAeCUv5rMXKrnJms',
                    GEOAPIFY: '5c607231c8c24f9b89ff3af7a110185b'
                };

                const BASE_MAPS = {
                    osm: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                    grod: 'https://mt0.google.com/vt/lyrs=r&x={x}&y={y}&z={z}',
                    ghyb: 'https://mt0.google.com/vt/lyrs=y,m&x={x}&y={y}&z={z}',
                    gsat: 'https://mt0.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'
                };

                const MAP_CONFIG = {
                    container: 'map',
                    style: `https://api.maptiler.com/maps/streets/style.json?key=${API_KEYS.MAPTILER}`,
                    center: [0, 0],
                    zoom: 1,
                    pitch: 0,
                    antialias: true
                };

                const map = new maplibregl.Map(MAP_CONFIG);

                function updateBaseMap(baseMapValue) {
                    let newStyle;
                    switch (baseMapValue) {
                        case 'maptiler':
                            newStyle = `https://api.maptiler.com/maps/streets/style.json?key=${API_KEYS.MAPTILER}`;
                            break;
                        case 'osm':
                            newStyle = {
                                version: 8,
                                sources: {
                                    'osm-tiles': {
                                        type: 'raster',
                                        tiles: [BASE_MAPS.osm],
                                        tileSize: 256,
                                    }
                                },
                                layers: [{
                                    id: 'osm-layer',
                                    type: 'raster',
                                    source: 'osm-tiles',
                                    minzoom: 0,
                                    maxzoom: 22
                                }]
                            };
                            break;
                        case 'grod':
                            newStyle = {
                                version: 8,
                                sources: {
                                    'google-tiles': {
                                        type: 'raster',
                                        tiles: [BASE_MAPS.grod],
                                        tileSize: 256,
                                    }
                                },
                                layers: [{
                                    id: 'google-layer',
                                    type: 'raster',
                                    source: 'google-tiles',
                                    minzoom: 0,
                                    maxzoom: 22
                                }]
                            };
                            break;
                        case 'gsat':
                            newStyle = {
                                version: 8,
                                sources: {
                                    'google-tiles': {
                                        type: 'raster',
                                        tiles: [BASE_MAPS.gsat],
                                        tileSize: 256,
                                    }
                                },
                                layers: [{
                                    id: 'google-layer',
                                    type: 'raster',
                                    source: 'google-tiles',
                                    minzoom: 0,
                                    maxzoom: 22
                                }]
                            };
                            break;
                        case 'ghyb':
                            newStyle = {
                                version: 8,
                                sources: {
                                    'google-tiles': {
                                        type: 'raster',
                                        tiles: [BASE_MAPS.ghyb],
                                        tileSize: 256,
                                    }
                                },
                                layers: [{
                                    id: 'google-layer',
                                    type: 'raster',
                                    source: 'google-tiles',
                                    minzoom: 0,
                                    maxzoom: 22
                                }]
                            };
                            break;
                    }

                    // Store current view state
                    const center = map.getCenter();
                    const zoom = map.getZoom();
                    const bearing = map.getBearing();
                    const pitch = map.getPitch();

                    // Update map style
                    map.setStyle(newStyle);

                    // Restore view state after style loads
                    map.once('style.load', () => {
                        map.setCenter(center);
                        map.setZoom(zoom);
                        map.setBearing(bearing);
                        map.setPitch(pitch);

                        // Re-add draw features if they exist
                        const features = draw.getAll();
                        if (features.features.length > 0) {
                            draw.deleteAll();
                            draw.add(features);
                        }
                    });
                }


                map.addControl(new maplibregl.NavigationControl());

                const urlParams = new URLSearchParams(window.location.search);
                const formid = urlParams.get('formid');
                const refid = urlParams.get('refid');
                const type = urlParams.get('type');

                let marker = null;

                function createCustomMarkerIcon(color, symbol) {
                    const img = document.createElement('img');
                    img.src = `https://api.geoapify.com/v1/icon/?type=awesome&color=%23${color}&icon=${symbol}&size=small&scaleFactor=2&apiKey=${API_KEYS.GEOAPIFY}`;
                    img.alt = 'Marker';
                    img.style.width = '35px';
                    img.style.height = '50px';
                    img.style.display = 'block';
                    return img;
                }

                function fetchFeatures(formid, refid) {
                    return fetch(`/api/v2/load_layer/${formid}/${refid}`).then(response => {
                        if (!response.ok) throw new Error(`Failed to fetch features: ${response.status}`);
                        return response.json();
                    });
                }

                async function updateFeatureStyle(formid, refid, style) {
                    return fetch('/api/v2/update_feature_style', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ formid, refid, style })
                    }).then(response => {
                        if (!response.ok) throw new Error(`Failed to update feature style: ${response.status}`);
                        return response.json();
                    });
                }

                async function updateFeatureGeojson(formid, refid, geojson, style) {
                    return fetch('/api/v2/update_feature', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ formid, refid, geojson, style })
                    }).then(response => {
                        if (!response.ok) throw new Error(`Failed to update feature geojson: ${response.status}`);
                        return response.json();
                    });
                }

                function getCustomStyles() {
                    const selectedIcon = document.getElementById('marker-icon').value;
                    return [
                        {
                            id: 'gl-draw-point',
                            type: 'circle',
                            filter: ['all', ['==', '$type', 'Point']],
                            paint: {
                                'circle-radius': parseInt(document.getElementById('point-radius').value),
                                'circle-color': document.getElementById('point-color').value,
                                'circle-stroke-width': 2,
                                'circle-stroke-color': '#FFFFFF'
                            },
                            metadata: { 'marker-icon': selectedIcon }
                        },
                        {
                            id: 'gl-draw-line',
                            type: 'line',
                            filter: ['all', ['==', '$type', 'LineString']],
                            paint: {
                                'line-color': document.getElementById('line-color').value,
                                'line-width': parseInt(document.getElementById('line-width').value)
                            }
                        },
                        {
                            id: 'gl-draw-polygon',
                            type: 'fill',
                            filter: ['all', ['==', '$type', 'Polygon']],
                            paint: {
                                'fill-color': document.getElementById('polygon-color').value,
                                'fill-opacity': parseFloat(document.getElementById('polygon-opacity').value)
                            }
                        },
                        {
                            id: 'gl-draw-polygon-outline',
                            type: 'line',
                            filter: ['all', ['==', '$type', 'Polygon']],
                            paint: {
                                'line-color': document.getElementById('line-color').value,
                                'line-width': parseInt(document.getElementById('line-width').value)
                            }
                        }
                    ];
                }

                function getMarkerIconFromStyles(styles) {
                    if (!Array.isArray(styles)) {
                        return 'map-marker';
                    }
                    const pointStyle = styles.find(style => style.id === 'gl-draw-point');
                    return pointStyle && pointStyle.metadata && pointStyle.metadata['marker-icon'] ? pointStyle.metadata['marker-icon'] : 'map-marker';
                }

                function calculateBounds(features) {
                    const bounds = new maplibregl.LngLatBounds();
                    features.features.forEach(feature => {
                        if (feature.geometry.type === 'Point') bounds.extend(feature.geometry.coordinates);
                        else if (feature.geometry.type === 'LineString') feature.geometry.coordinates.forEach(coord => bounds.extend(coord));
                        else if (feature.geometry.type === 'Polygon') feature.geometry.coordinates[0].forEach(coord => bounds.extend(coord));
                    });
                    return bounds;
                }

                const styleResponse = await fetch(`/api/v2/load_feature_style/${formid}/${refid}`);
                const styleData = await styleResponse.json();
                let json = [];
                try {
                    json = styleData.style ? JSON.parse(styleData.style) : [];
                } catch (e) {
                    console.error('Error parsing style JSON:', e);
                    json = [];
                }

                if (!json.length || !json[0]) json[0] = { paint: { 'circle-color': '#FF0000', 'circle-radius': 4, 'circle-stroke-width': 2, 'circle-stroke-color': '#FFFFFF' }, metadata: { 'marker-icon': 'map-marker' } };
                if (!json[1]) json[1] = { paint: { 'line-color': '#00FF00', 'line-width': 2 } };
                if (!json[2]) json[2] = { paint: { 'fill-color': '#0000FF', 'fill-opacity': 0.5 } };

                document.getElementById('point-color').value = json[0].paint['circle-color'] || '#FF0000';
                document.getElementById('point-radius').value = json[0].paint['circle-radius'] || 4;
                document.getElementById('line-color').value = json[1].paint['line-color'] || '#00FF00';
                document.getElementById('line-width').value = json[1].paint['line-width'] || 2;
                document.getElementById('polygon-color').value = json[2].paint['fill-color'] || '#0000FF';
                document.getElementById('polygon-opacity').value = json[2].paint['fill-opacity'] || 0.5;
                document.getElementById('marker-icon').value = getMarkerIconFromStyles(json);

                let draw = new MapboxDraw({
                    displayControlsDefault: false,
                    controls: { point: type === 'Point', line_string: type === 'LineString', polygon: type === 'Polygon', trash: false },
                    styles: json.length ? json : getCustomStyles()
                });

                map.addControl(draw);

                let existingFeatures = null;
                const offset = [0, -16];


                const updateData = async (formid, refid) => {
                    try {
                        const formData = Object.fromEntries(
                            Array.from(document.getElementById('formContainer').querySelectorAll('input, select, textarea'))
                                .map(input => [input.name, input.value])
                        );

                        await fetchAPI(`/api/v2/update_row/${formid}/${refid}`, {
                            method: 'PUT',
                            body: JSON.stringify(formData)
                        });
                        alert('Data updated successfully!');
                    } catch (error) {
                        console.error('Error updating data:', error);
                        alert('Failed to update data.');
                    }
                };

                const generateFormFields = (columnsData, rowData, formid, refid) => {
                    const formContainer = document.getElementById('formContainer');
                    formContainer.innerHTML = '';

                    columnsData.forEach(column => {
                        const formGroup = document.createElement('div');
                        formGroup.className = 'form-group';

                        const label = document.createElement('label');
                        label.textContent = column.col_name;
                        label.setAttribute('for', column.col_id);

                        const input = document.createElement('input');
                        input.id = column.col_id;
                        input.name = column.col_id;
                        input.className = 'form-control';
                        input.placeholder = column.col_desc;
                        input.type = { text: 'text', numeric: 'number', date: 'date' }[column.col_type] || 'text';

                        if (rowData?.[column.col_id] !== undefined) {
                            input.value = column.col_type === 'date' && rowData[column.col_id]
                                ? new Date(rowData[column.col_id]).toISOString().split('T')[0]
                                : rowData[column.col_id];
                        }

                        formGroup.append(label, input);
                        formContainer.appendChild(formGroup);
                    });

                    const saveButton = document.createElement('button');
                    saveButton.textContent = 'Save';
                    saveButton.className = 'btn btn-primary';
                    saveButton.addEventListener('click', () => updateData(formid, refid));
                    formContainer.appendChild(saveButton);
                };

                const fetchAPI = async (url, options = {}) => {
                    const response = await fetch(url, { ...options, headers: { 'Content-Type': 'application/json', ...options.headers } });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response.json();
                };

                const [columnsData, featuresData] = await Promise.all([
                    fetchAPI(`/api/v2/load_layer_description/${formid}`),
                    fetchAPI(`/api/v2/load_layer/${formid}/${refid}`)
                ]);

                generateFormFields(columnsData, featuresData[0], formid, refid);

                document.getElementById('baseMapSelector').addEventListener('change', (e) => {
                    updateBaseMap(e.target.value);
                });

                document.getElementById('searchLatLng')?.addEventListener('submit', e => {
                    e.preventDefault();
                    const [lat, lng] = ['latitude', 'longitude'].map(id => parseFloat(document.getElementById(id).value));
                    if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                        return alert('Please enter valid latitude (-90 to 90) and longitude (-180 to 180) values.');
                    }
                    map.flyTo({ center: [lng, lat], zoom: 15 });
                    new maplibregl.Marker().setLngLat([lng, lat]).addTo(map);
                });

                document.getElementById('clear-marker')?.addEventListener('click', () => {
                    document.querySelectorAll('.maplibregl-marker').forEach(marker => marker.remove());
                    ['latitude', 'longitude'].forEach(id => document.getElementById(id).value = '');
                });

                document.getElementById('styleForm').addEventListener('submit', async (e) => {
                    e.preventDefault();

                    const currentStyles = getCustomStyles();
                    const stylesJson = JSON.stringify(currentStyles, null, 2);
                    await updateFeatureStyle(formid, refid, stylesJson);

                    const currentFeatures = draw.getAll();
                    map.removeControl(draw);
                    draw = new MapboxDraw({
                        displayControlsDefault: false,
                        controls: { point: type === 'Point', line_string: type === 'LineString', polygon: type === 'Polygon', trash: false },
                        styles: currentStyles
                    });
                    map.addControl(draw);
                    if (currentFeatures && currentFeatures.features.length > 0) {
                        draw.add(currentFeatures);
                        if (type === 'Point' && currentFeatures.features[0]) {
                            const pointCoordinates = currentFeatures.features[0].geometry.coordinates;
                            if (marker) marker.remove();
                            const selectedIcon = getMarkerIconFromStyles(currentStyles);
                            const markerIcon = createCustomMarkerIcon(document.getElementById('point-color').value.slice(1), selectedIcon);
                            marker = new maplibregl.Marker({ element: markerIcon, offset }).setLngLat(pointCoordinates).addTo(map);
                        }
                    } else if (existingFeatures) {
                        draw.add(existingFeatures);
                    }
                });

                map.on('load', async () => {
                    try {
                        const featureData = await fetchFeatures(formid, refid);
                        let geojsonData;
                        if (Array.isArray(featureData) && featureData.length > 0 && featureData[0].geojson) {
                            const parsed = JSON.parse(featureData[0].geojson);
                            if (parsed.type === 'Polygon' || parsed.type === 'Point' || parsed.type === 'LineString') {
                                geojsonData = { type: 'FeatureCollection', features: [{ type: 'Feature', geometry: parsed, properties: {} }] };
                            } else {
                                geojsonData = parsed;
                            }
                        } else if (featureData.features) {
                            geojsonData = featureData;
                        } else {
                            throw new Error('Unexpected API response structure');
                        }

                        if (!geojsonData || !geojsonData.features || !Array.isArray(geojsonData.features)) {
                            throw new Error(`Invalid GeoJSON structure: ${JSON.stringify(geojsonData)}`);
                        }

                        existingFeatures = geojsonData;
                        draw.add(existingFeatures);

                        if (existingFeatures.features.length > 0) {
                            const bounds = calculateBounds(existingFeatures);
                            if (!bounds.isEmpty()) map.fitBounds(bounds, { padding: 50 });

                            if (type === 'Point') {
                                const pointCoordinates = existingFeatures.features[0].geometry.coordinates;
                                if (marker) marker.remove();
                                const storedIcon = getMarkerIconFromStyles(json);
                                const markerIcon = createCustomMarkerIcon(json[0].paint['circle-color'].slice(1), storedIcon);
                                marker = new maplibregl.Marker({ element: markerIcon, offset }).setLngLat(pointCoordinates).addTo(map);
                            }
                        }
                    } catch (error) {
                        console.error('Error loading default features:', error);
                    }

                    map.on('draw.create', async (e) => {
                        const currentStyles = getCustomStyles();
                        const styleJson = JSON.stringify(currentStyles);
                        const geojsonJson = JSON.stringify(e.features[0].geometry);
                        const allFeatures = draw.getAll();
                        allFeatures.features.forEach(async (feature) => {
                            if (!e.features.some((newFeature) => newFeature.id === feature.id)) draw.delete(feature.id);
                        });

                        try {
                            await updateFeatureGeojson(formid, refid, geojsonJson, styleJson);
                            if (type === 'Point') {
                                const pointCoordinates = e.features[0].geometry.coordinates;
                                if (marker) marker.remove();
                                const selectedIcon = getMarkerIconFromStyles(currentStyles);
                                const markerIcon = createCustomMarkerIcon(document.getElementById('point-color').value.slice(1), selectedIcon);
                                marker = new maplibregl.Marker({ element: markerIcon, offset }).setLngLat(pointCoordinates).addTo(map);
                            }
                        } catch (error) {
                            console.error('Error updating feature on draw.create:', error);
                        }
                    });

                    map.on('draw.delete', (e) => {
                        if (type === 'Point' && marker) {
                            marker.remove();
                            marker = null;
                        }
                    });

                    map.on('draw.update', async (e) => {
                        const currentStyles = getCustomStyles();
                        const styleJson = JSON.stringify(currentStyles);
                        const geojsonJson = JSON.stringify(e.features[0].geometry);

                        try {
                            await updateFeatureGeojson(formid, refid, geojsonJson, styleJson);
                            if (type === 'Point') {
                                const pointCoordinates = e.features[0].geometry.coordinates;
                                if (marker) marker.remove();
                                const selectedIcon = getMarkerIconFromStyles(currentStyles);
                                const markerIcon = createCustomMarkerIcon(document.getElementById('point-color').value.slice(1), selectedIcon);
                                marker = new maplibregl.Marker({ element: markerIcon, offset }).setLngLat(pointCoordinates).addTo(map);
                            }
                        } catch (error) {
                            console.error('Error updating feature on draw.update:', error);
                        }
                    });
                });
            } catch (error) {
                console.log('error', error);
            }
        });
    </script>
</body>

</html>